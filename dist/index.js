import y from"onnxruntime-node";import v from"sharp";var x=t=>{let s=t.map(e=>Math.exp(e)).reduce((e,a)=>e+a,0);return t.map(e=>Math.exp(e)/s)};var i=class extends Error{constructor(){super("The inference model has not been initialized.")}},o=class extends Error{constructor(e){super("Image format conversion by sharp failed.");this.error=e}},r=class extends Error{constructor(){super("An internal error has occurred.")}},c=class{constructor(s){this.model=s}size=224;output="logits";session=null;get initialized(){return this.session!==null}async initialize(){this.initialized&&await this.dispose(),this.session=await y.InferenceSession.create(this.model)}async inference(s){if(this.initialized||await this.initialize(),this.session===null)throw new i;let e=await(async()=>{try{return await v(s).resize(this.size,this.size,{kernel:"nearest",fit:"fill"}).removeAlpha().raw().toBuffer()}catch(n){return n instanceof Error?new o(n):new r}})();if(e instanceof Error)throw e;let a=[],l=[],p=[];for(let n=0;n<e.byteLength;n+=3){let m=e[n+0];if(m===void 0)throw new r;a.push(m);let w=e[n+1];if(w===void 0)throw new r;l.push(w);let b=e[n+2];if(b===void 0)throw new r;p.push(b)}let z=[...a,...l,...p].map(n=>(n/255-.5)/.5),f=new y.Tensor(new Float32Array(z),[1,3,this.size,this.size]),u=(await this.session.run({pixel_values:f}))[this.output];if(u===void 0)throw new r;let d=u.data;if(!(d instanceof Float32Array))throw new r;let[,h]=x([...d]);if(h===void 0)throw new r;return f.dispose(),u.dispose(),h}async dispose(){await this.session?.release()}};var L={InitializationError:i,SharpError:o,InternalError:r};export{c as EchikanaInferencer,L as errors};
